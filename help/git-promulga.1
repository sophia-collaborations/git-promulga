.TH GIT-PROMULGA 1
.SH NAME
git-promulga - A nutbag system for advanced synchronization operations in Git.
.SH SYNOPSIS
.B git-promulga
[\fIoptions\fR]
.SH DESCRIPTION
\fBgit-promulga\fR does advanced synchronization-related operations
that are configured specifically for each individual clone of a
Git repository.

The first thing that \fBgit-promulga\fR is
search for the containing \fBgit-promulga\fR eligible
directory.
To do this, it keeps searching up and up the directory tree
(starting with the current-working-directory
and moving on up)
until it finds a containing directory
that contains within it a sub-directory named \(dqgit\(dq
(which is the sign it checks for presence in a Git
directory) as well as the file \(dq.promulga/main.dat\(dq
(who's presence automatically implies the existence of
the \(dq.promulga\(dq sub-direrectory.

The last criterion \fBgit-promulga\fR looks for is
that the \(dq.gitignore\(dq file has the line \(dq/.promulga\(dq.
It checks for this because the contents of the
\(dq.promulga\(dq directory are specific
to individual clones of the repository.
For this reason, if it does not find that line
in the \(dq.gitignore\(dq file, the current directory
will fail the test for promulgation eligibility,
and the search will continue to the next
directory up the tree.

So in short - \fBgit-promulga\fR is looking for
the head directory of a git project who's local clone
is configured for \fBgit-promulga\fR.
When it finds that directory,
it loads the contents of the \(dq.promulga/main.dat\(dq
file (known as the \(dqdirective file\(dq), and carries out every
directive in that
file that is applicable to the mode that it is
being run in (which is \(dqmain\(dq by default, but can
be changed by the \fB-md\fR command-line option described
in the section of this manual page labeled \(dqOptions\(dq).

For more information on the structure of the directive file, see
the section of this manual-page labeled \(dqThe Directive File\(dq.
.SH OPTIONS
The options are processed in the order that they appear on the command line.
Each option overrides any earlier option to it's contrary.
.TP
.BR --help
Displays this help file - and exits the program once
you are finished reading it.
.TP
.BR -md " " [\fImode\fR]
Sets the mode (which in turn determines which directives are
carried out) to the one identified by the name \fImode\fR.
A mode-name should only have alphanumeric characters in it
(as well as the occasional underscore that is permitted
just in case one needs it to separage words within a mode name) -
and is case-sensitive.
The default value is \(dqmode\(dq.
.SH THE DIRECTIVE FILE
There are two kinds of lines in the Directive File -
validation lines and directive lines.

The first part of each line
(that is, everything before the first-colon)
is known as the 'modal section'
and it is a list of all the modes that the
line pertains to separated by forward-slashes.
In the case of validation lines, all items on
this list must be the literal names of modes.
In the case of directive lines, however,
an item could simply be an asterik ('*')
thereby refering collectively to all modes
that have been thus-far validated.
The reason why such wild-carding is not allowed
in validation lines is because each mode, to be
valid, must be specifically specified
(and the default mode of \(dqmain\(dq is not
exempt from this criterion).

The second part of each line (that is, everything
between the first colon and the second colon)
is known as the 'activity section'.
If it's value is \(dqvalid\(dq, that signifies
a validation line.
Otherwise, it contains a string specifying what
type of directive if is.
The different possible values of this section
are detailed in the section of this manual-page
labeled \(dqDirective Types\(dq.

In a sense, one might be tempted to think
of validation lines as regular directive
lines of directive-type \(dqvalid\(dq.
However - there are a few distinctions.
One, of course, is that wild-carding of
mode-names is not permitted in these lines.
The other is that no directive line is allowed
to apply to any specific mode (even if it's
name is specifically listed in the modal section)
unless a validation line has specified it first.

The third section of the line is known as the 'content section'.
It simply contains any argumentation needed for a directive.
Since the two colons that separate the sections of the line
all come before this section, this is the only section that
can have colons within it.
As a matter of fact, any colon in the content section
(that is, any colon in the entire line other than the first two)
may simply be no more than a literal colon - unless the
function of the directive-type specifies otherwise.

In case this is too abstract,
let's look at a little sample.

.RS 3
main:\fIvalid\fR:
.br
out/in:\fIvalid\fR:
.br
*:\fIcommit\fR:
.br
*:\fIremotes\fR:origin:
.br
main/in:\fIpull\fR:master:dev:
.br
*:\fImerge\fR:dev:master:dev:
.br
main/out:\fIpush\fR:master:dev:
.br
main/out:\fIsh\fR:ssh myself@some.where
.br
      < \(dq${GIT_PROMULGA_DIR}/to-myself.cmd\(dq
.RE

Let's look at it again - this time with line-number labels
for reference sake (a convention that will be followed for all
sample-files for the remainder of this manual-page).

.RS 3
 \fB1\fR: main:\fIvalid\fR:
.br
 \fB2\fR: out/in:\fIvalid\fR:
.br
 \fB3\fR: *:\fIcommit\fR:
.br
 \fB4\fR: *:\fIremotes\fR:origin:
.br
 \fB5\fR: main/in:\fIpull\fR:master:dev:
.br
 \fB6\fR: *:\fImerge\fR:dev:master:dev:
.br
 \fB7\fR: main/out:\fIpush\fR:master:dev:
.br
 \fB8\fR: main/out:\fIsh\fR:ssh myself@some.where
.br
 \fB8\fR(cont):    < \(dq${GIT_PROMULGA_DIR}/to-myself.cmd\(dq
.RE

In addition to the fact that we now have line-numbers
by which to reference the lines in the description,
it is now also clear that Line 8 (though divided into
two lines in this manual-page for the sake of typesetting)
must, in fact, be a single line in the actual file
being described.

Okay - in this repository, \fBgit-promulga\fR recognizes
three modes ("main" specified in line 1 and "out" and "in"
specified in line 2).

Line 3 is a directive of type "commit".
As the mode listed is the wild-card asterik,
it pertains to all modes that have thus-far
been validated.
Directives of this type do more than just "git commit".
They also take care of all the staging and everything
so that you don't have to worry about that.

So, if \fBgit-promulga\fR is invoked with a valid mode,
then after line 3, all changes since last time will have
been staged and committed. However, they will be restricted
to the local repository.

Line 4 is a directive of type \(dqremotes\(dq.
It's content section is nothing more or less than
a colon-separated list of all the Git remotes that
subsequent pull and push commands will pull and push from
(at least until a later directive of this type changes it).
For this reason, in the next line (Line 5), it is
from the \(dqorigin\(dq remote that the \(dqmaster\(dq branch
and then the \(dqdev\(dq branch are pulled.

After Line 5, the local clone will have the \(dqdev\(dq branch
checked out (if it exists - more on
the limitations of this directive-type
in it's section) because that is the last branch
listed in this line.

Line 5, of course, will be ignored if the mode that
the program is run in is \(dqout\(dq, because the
modal section limits it to the \(dqmain\(dq
and \(dqin\(dq modes.

Line 6 merges the two branches of the local repository
- once again (usually) leaving the \(dqdev\(dq branch
checked out - because it is (once again) the last
branch mentioned.

Line 7 simiarly pushes the commits of the \(dqmaster\(dq
and \(dqdev\(dq branches (still to the \(dqorigin\(dq
remote, because that never got changed) - unless
\fBgit-promulga\fR is running in mode \(dqin\(dq.

Finally comes Line 8, a directive of type \(dqsh\(dq
- which means that it's content section is simply run
as-is as a shell-command.
This line (unless your are in mode \(dqin\(dq)
opens a SSH connection to the account \(dqmyself\(dq
on the server \(dqsome.where\(dq (presumably
where the \(dqorigin\(dq branch is located).
Instead of opening a terminal session on SSH,
it pipes to SSH the contents of the file
\(dqto-myself.cmd\(dq inside of the
\fBgit-promulga\fR configuration directory.
This file one might simply reference as \(dq.promulga/to-myself.cmd\(dq,
since all these shell commands are executed from the head
directory of the Git repository.
However, since in the not-too-distant future,
there will be alternate possible locations for the
configuration directory, it is better to reference
it through the \fBGIT_PROMULGA_DIR\fR environment
variable rather than by it's
literal name of \(dq.promulga\(dq.

As noted - the source that gets piped to SSH
is in the \(dq.promulga\(dq directory.
This is because \fBgit-promulga\fR insists
that the entire directory must be git-ignored,
yet \(dqmain.dat\(dq is the only file within it
that is of special significance to \fBgit-promulga\fR.
That makes this directory a convenient place
to put resource files like this.

But before we end this section of the documentation there is
one more thing to discuss.
Everything we did so far is fine if the
server we are working with grants access absolutely 100% of the
time and the internet connection to it is equally reliable.
Unfortunately, we all know that this is a dubious
proposition.
For this reason, we have directive-types that use a feature
called 'persistence'.
That means that if certain actions do not work the first
time, they try again.

Here is a version of the sample "main.dat" above,
only modified so that it uses
such directive-types.

.RS 3
 \fB1\fR: main:\fIvalid\fR:
.br
 \fB2\fR: out/in:\fIvalid\fR:
.br
 \fB3\fR: *:\fIcommit\fR:
.br
 \fB4\fR: *:\fIprcset\fR:5/10/15/20/25/30/35/40/45/50/55/60:
.br
 \fB5\fR: *:\fIremotes\fR:origin:
.br
 \fB6\fR: main/in:\fIprcpull\fR:master:dev:
.br
 \fB7\fR: *:\fImerge\fR:dev:master:dev:
.br
 \fB8\fR: main/out:\fIprcpush\fR:master:dev:
.br
 \fB9\fR: main/out:\fIprcsh\fR:ssh myself@some.where
.br
 \fB9\fR(cont):    < \(dq${GIT_PROMULGA_DIR}/to-myself.cmd\(dq

A new Line 4 is added (causing the old Lines 4 thru 8 to now
become Lines 5 thru 9).
This new Line 4 is of directive-type "prcset".
It sets the persistence schedule - which is a list
of numbers separated by forward-slashes.
As a result of Line 4, henceforth,
if a persistent operation fails, it will be attempted again
5 seconds afterwards.
If again it fails, it will wait another 10 seconds and try again --
then, upon another failure, 15 seconds - and so forth.
Hopefully, the operation will succeed before it reaches the end
of the list.
But if at the end (if it fails after the final wait - which is 60-seconds)
then it will give up and move on.

A few of the later directives have been modified to use this
persistence.
For example, the "pull" directives have been replaced
with "prcpull" directives.
The only difference is that the "git pull" command
invoked for every remote-branch combination will be called
with this persistence.
And to do the same for "git push" commands invoked,
the "push" directives have been replaced by "prcpush"
directives.

Last but not least - the "sh" directive has been replaced
by a "prcsh" directive - meaning that if the shell command
returns an error, it will be called over and over with
such persistence in hopes that it returns without error
before the persistence line runs out.


















